#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse, asyncio, json, sys
from pathlib import Path
from typing import List

# ---- パス解決（scripts/ の 1つ上 = Generate_Synthetic_Data、その親がプロジェクトルート）----
SCRIPT_PATH = Path(__file__).resolve()
REPO_ROOT   = SCRIPT_PATH.parents[1]          # .../Generate_Synthetic_Data
PROJECT_ROOT= REPO_ROOT.parent                # .../ax-cpt
ENTIGRAPH_PY= REPO_ROOT / "data" / "entigraph.py"  # .../Generate_Synthetic_Data/data/entigraph.py

def load_uids_from_jsonl(path: Path) -> List[str]:
    uids: List[str] = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                uids.append("")
                continue
            try:
                obj = json.loads(line)
            except Exception:
                uids.append("")
                continue
            uids.append(str(obj.get("uid", "")))
    return uids

async def run_one(index: int, model_tag: str):
    # entigraph.py は相対パスで data/… を参照する想定が多いので cwd=PROJECT_ROOT に固定
    if not ENTIGRAPH_PY.exists():
        raise FileNotFoundError(f"entigraph.py not found: {ENTIGRAPH_PY}")

    proc = await asyncio.create_subprocess_exec(
        sys.executable, str(ENTIGRAPH_PY),
        str(index),
        "--model-name", model_tag,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
        cwd=str(PROJECT_ROOT),  # ← ここが重要
    )
    out, err = await proc.communicate()
    if proc.returncode != 0:
        raise RuntimeError(
            f"[index={index}] entigraph.py failed (code={proc.returncode})\n"
            f"STDOUT:\n{out.decode(errors='ignore')}\n"
            f"STDERR:\n{err.decode(errors='ignore')}\n"
        )
    return out.decode(errors="ignore")

async def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--source-jsonl", required=True,
                    help="例: data/dataset/source/mycorpus.jsonl  (相対ならプロジェクトルート基準)")
    ap.add_argument("--out-dir-root", default="data/dataset/raw",
                    help="例: data/dataset/raw  (相対ならプロジェクトルート基準)")
    ap.add_argument("--model-tag", required=True)
    ap.add_argument("--start", type=int, required=True)
    ap.add_argument("--end", type=int, required=True)
    ap.add_argument("--concurrency", type=int, default=256)
    ap.add_argument("--force", action="store_true")
    args = ap.parse_args()

    # 相対パスはプロジェクトルート基準に解決（../data 配置の要望にも対応）
    def resolve_under_root(p: str) -> Path:
        q = Path(p)
        return q if q.is_absolute() else (PROJECT_ROOT / q)

    src = resolve_under_root(args.source_jsonl)
    out_root = resolve_under_root(args.out_dir_root)

    if not src.exists():
        raise FileNotFoundError(f"source-jsonl not found: {src}")

    # 進捗・スキップ判定のために UID を読み込み
    uids = load_uids_from_jsonl(src)
    n_total = len(uids)

    out_dir = out_root / f"quality_entigraph_{args.model_tag}"
    out_dir.mkdir(parents=True, exist_ok=True)

    todo: List[int] = []
    for i in range(args.start, args.end):
        if i < 0 or i >= n_total:
            continue
        uid = uids[i]
        out_path = out_dir / f"{uid}.json" if uid else None
        if out_path and out_path.exists() and not args.force:
            print(f"[skip] {uid} (index={i})")
            continue
        todo.append(i)

    if not todo:
        print("Nothing to do. (All outputs exist or range empty)")
        return

    print(f"Plan: run entigraph.py for {len(todo)} items "
          f"(range {args.start}..{args.end}, concurrency={args.concurrency})")
    print(f"[paths] project_root={PROJECT_ROOT}")
    print(f"[paths] entigraph_py={ENTIGRAPH_PY}")
    print(f"[paths] source_jsonl={src}")
    print(f"[paths] out_dir={out_dir}")

    sem = asyncio.Semaphore(args.concurrency)
    ok = 0
    fail = 0

    async def bound_run(i: int):
        nonlocal ok, fail
        async with sem:
            try:
                _ = await run_one(i, args.model_tag)
                ok += 1
                if ok % 20 == 0:
                    print(f"[progress] ok={ok} fail={fail}")
            except Exception as e:
                fail += 1
                print(f"[error] index={i}: {e}")

    await asyncio.gather(*[bound_run(i) for i in todo])
    print(f"Done. ok={ok} fail={fail}")

if __name__ == "__main__":
    asyncio.run(main())
